pipeline {
    agent any
    tools {
        maven 'M3'
    }
    environment {
        // all environment variables have the type "String" (also 'isRelease = false')
        gitCredentialsId = 'github-jenkins-ssh'
        OpenShiftProjectDev = 'axa-advice-sme-dev-axa-ch'
        OpenShiftClusterName = 'axa-advice-sme-dev-axa-ch-private-blue'
        //projects = 'application-form-domain,consultant-domain,meeting-minutes-domain,pdsdocument-domain,activity-domain,partner-domain'
    }
    parameters {
        booleanParam(
                name: 'PREPARE_RELEASE',
                description: 'Should create a new release branch and increment the version',
                defaultValue: false
        )
        string(
                name: 'DEPLOYMENT_BRANCH',
                description: 'Branch from which to trigger the deployments',
                defaultValue: env.BERATUNGS_SERVICES_MODULES_DEPLOYMENT_BRANCH ?: "development"
        )
    }
    stages {
        stage('Verify NOT Jenkins automated commit') {
            when {
                expression {
                    return wasLastCommitAutomated()
                }
            }
            steps {
                script {
                    currentBuild.displayName = "NOT_BUILT"
                    currentBuild.description = 'last commit contained the string "[maven-release-build]". Inside our multibranch pipeline, this must not trigger another build to prevent build loops on development branch.'
                    currentBuild.result = 'NOT_BUILT'
                }
                error('Skipping release build')
            }
        }
        stage('Set variables') {
            steps {
                script {
                    // initialise the pipeline internal variables with "script" scope (they are available for all subsequent stages)
                    // they need to be of type boolean - otherwise the conditions will still work, but unexpected
                    // (e.g. 'false' evaluates to true in Groovy, '' evaluates to false)
                    isRelease = false
                    if (isMultibranchPipeline()) {
                        gitBranch = GIT_BRANCH
                    } else {
                        gitBranch = params.BUILD_BRANCH_NAME
                    }
                    if (isDevelopmentBranch() && params.PREPARE_RELEASE) {
                        isRelease = true
                    }
                    sh 'git config --global user.email "srdjan@3ap.ch"'
                    sh 'git config --global user.name "Srdjan Obradovic"'
                    // fix "detached HEAD" state
                    sh "git checkout ${gitBranch}"
                }
            }
        }
        stage('Prepare for new release') {
            when {
                expression {
                    return isRelease
                }
            }
            steps {
                script {
                    try {
                        sshagent([gitCredentialsId]) {
                            sh 'mvn --batch-mode clean build-helper:parse-version release:prepare -DdevelopmentVersion=\\\${parsedVersion.majorVersion}.\\\${parsedVersion.nextMinorVersion}.0-SNAPSHOT release:perform -Darguments="-Dmaven.deploy.skip=true -Dmaven.javadoc.skip=true"'
                            def latestTag = sh(
                                    returnStdout: true,
                                    script: 'git describe --tags `git rev-list --tags --max-count=1`'
                            ).trim()
                            sh "git checkout \$tag -b release/${latestTag}"
                            sh "git push -u origin release/${latestTag}"
                            echo "Created new release branch: release/${latestTag}"
                        }
                    } catch (exc) {
                        echo 'Cleaning up after fail'
                        sh 'mvn release:clean'
                        throw (exc)
                    }
                }
            }
        }
        stage('Build') {
            when {
                expression {
                    return !isRelease
                }
            }
            steps {
                script {
                    sh "mvn --also-make package -Dmaven.repo.local=/var/lib/jenkins/wd/.m2"
                }
            }
        }
//        stage('Update versions and tag') {
//            when {
//                not { expression { return isRelease } }
//            }
//            steps {
//                script {
//                    if (branch pattern: "release/\\.+") {
//                        sshagent([gitCredentialsId]) {
//                            //  sh 'mvn build-helper:parse-version versions:set -DnewVersion=\\\${parsedVersion.majorVersion}.\\\${parsedVersion.minorVersion}.\\\${parsedVersion.nextIncrementalVersion}-\\\${parsedVersion.qualifier} versions:commit -Dmessage="[automated-commit] Incremented patch version" scm:checkin scm:tag -Dtag=\\\${project.version}'
//                        }
//                    } else {
//                        sshagent([gitCredentialsId]) {
//                            //  sh 'mvn build-helper:parse-version versions:set -DnewVersion=\\\${parsedVersion.majorVersion}.\\\${parsedVersion.minorVersion}.\\\${parsedVersion.nextIncrementalVersion}-\\\${parsedVersion.qualifier} versions:commit -Dmessage="[automated-commit] Incremented patch version" scm:checkin scm:tag -Dtag=\\\${project.version}'
//                        }
//                    }
//                }
//            }
//        }
        stage('Update versions and tag - SNAPSHOT') {
            when {
                allOf {
                    not { expression { return isRelease } }
                    branch 'develop'
                }
            }
            steps {
                script {
                    sshagent([gitCredentialsId]) {
                        sh 'mvn build-helper:parse-version versions:set -DnewVersion=\\\${parsedVersion.majorVersion}.\\\${parsedVersion.minorVersion}.\\\${parsedVersion.nextIncrementalVersion}-\\\${parsedVersion.qualifier} versions:commit -Dmessage="[automated-commit] Incremented patch version" scm:checkin scm:tag -Dtag=\\\${project.version}'
                    }
                }
            }
        }
        stage('Update versions and tag - RELEASE FIX') {
            when {
                allOf {
                    not { expression { return isRelease } }
                    branch pattern: "release/\\.+"
                }
            }
            steps {
                script {
                    sshagent([gitCredentialsId]) {
                        sh 'mvn build-helper:parse-version versions:set -DnewVersion=\\\${parsedVersion.majorVersion}.\\\${parsedVersion.minorVersion}.\\\${parsedVersion.nextIncrementalVersion} versions:commit -Dmessage="[automated-commit] Incremented patch version" scm:checkin scm:tag -Dtag=\\\${project.version}'
                    }
                }
            }
        }
        stage('Deploy all domains') {
            when {
                expression {
                    return shouldDeploy()
                }
            }
            steps {
                script {
                    def projectVersion = getVersionFromPom()
                    echo "projectVersion = ${getVersionFromPom()}"
                    //run_s2i_build(['activity-domain', 'application-form-domain', 'consultant-domain', 'meeting-minutes-domain', 'partner-domain', 'pdsdocument-domain'], projectVersion)
                    //slackSend(color: 'good', message: "Microservices ${projectVersion} successfully deployed.", channel: "#qa-sme")
                }
            }
        }
    }
    post {
        success {
            //slackSend(color: 'good', message: "Build - ${JOB_NAME} ${BUILD_NUMBER} successful. (<${BUILD_URL}|Open output>)", channel: "#jenkins-sme")
            echo 'BUILD SUCCESSFUL.'
        }
        failure {
            //slackSend(color: '#FF0000', message: ":warning: Build - ${JOB_NAME} ${BUILD_NUMBER} failed! (<${BUILD_URL}|Open output>) :warning:", channel: "#jenkins-sme")
            echo 'BUILD FAILED!'
        }
    }
}

def run_s2i_build(domains, projectVersion) {
    def buildConfig = ["activity-domain"        : "sme-activity",
                       "application-form-domain": "sme-application-form",
                       "consultant-domain"      : "sme-consultant",
                       "meeting-minutes-domain" : "sme-meeting-minutes",
                       "partner-domain"         : "sme-partner",
                       "pdsdocument-domain"     : "sme-pdsdocument"]
    domains.each { domain ->
        openshift.withCluster(OpenShiftClusterName) {
            openshift.withProject(OpenShiftProjectDev) {
                echo "start build for ${domain}"
                def bc = openshift.selector("bc", "${buildConfig.get(domain)}")
                bc.startBuild("--from-file=${domain}/target/${domain}-${projectVersion}.jar")
                timeout(time: 4, unit: 'MINUTES') {
                    bc.logs('-f')
                }
                def lastVersion = bc.object().status.lastVersion
                def pod = openshift.selector('pod', "${buildConfig.get(domain)}-${lastVersion}-build")
                def status = waitForTermination(pod)
                if (status == 'Failed') {
                    error('build failed')
                }
                echo "tagging ${buildConfig.get(domain)}:latest -> ${buildConfig.get(domain)}:${projectVersion}"
                openshift.tag("${buildConfig.get(domain)}:latest", "${buildConfig.get(domain)}:${projectVersion}")
            }
        }
    }
}
/**
 * returns true, if the last commit was created by a release build (i.e. contains "maven-release-plugin")
 */
def wasLastCommitAutomated() {
    def lastCommit = sh returnStdout: true, script: 'git log -1 --pretty=%B'
    echo "lastCommit=${lastCommit}"

    if (params.PREPARE_RELEASE) {
        return false
    }

    return lastCommit.contains("[maven-release-plugin]") || lastCommit.contains("[automated-commit]")
}
/**
 * returns true, if this build is our multibranch pipeline + branch to be built is "development"
 */
def isDevelopmentBranchInMultibranchPipeline() {
    // in a multibranch pipeline build, the JOB_NAME follows the pattern "JOB_NAME"/"BRANCH_NAME"
    // in a simple pipeline, it is ["FOLDER_NAME"/]"JOB_NAME"
    return env.JOB_NAME.endsWith("/develop")
}
/**
 * returns true, if this build is our multibranch pipeline
 */
def isMultibranchPipeline() {
    // in a multibranch pipeline build, the GIT_BRANCH just contains the branch name
    // in a simple pipeline, it is "origin/branch-name"
    return !GIT_BRANCH.startsWith("origin/")
}
/**
 * returns true, if this build is our multibranch pipeline
 */
def isReleaseBranch() {
    // in a multibranch pipeline build, the GIT_BRANCH just contains the branch name
    // in a simple pipeline, it is "origin/branch-name"
    return GIT_BRANCH.startsWith("release/")
}
// Convenience Functions to read variables from the pom.xml
// Do not change anything below this line.
// --------------------------------------------------------
def getVersionFromPom() {
    def pom = readMavenPom file: 'pom.xml'
    return pom.version
}

def getReleaseVersion(releaseFile) {
    def props = readProperties file: releaseFile
    return props['project.rel.com.axa.ch.bers:beratungs-services']
}
/**
 * returns true, if this build is development branch
 */
def isDevelopmentBranch() {
    return JOB_NAME.endsWith("/develop")
}

def shouldDeploy() {
    if (params.PREPARE_RELEASE) {
        return false;
    }
    if (params.DEPLOYMENT_BRANCH == "development" && isDevelopmentBranch()) {
        return true
    }
    return params.DEPLOYMENT_BRANCH == GIT_BRANCH && isReleaseBranch()
}